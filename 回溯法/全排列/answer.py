# coding:utf-8
"""
给出一个列表，列表中是不重复的元素，
将元素进行排列，一共有多少种排列方式

解题思路：

以字符串列表['a', 'b', 'c']为例，我们逐个位确定全排列的所有可能。
回溯法的原理在于在前n-1位元素确定的情况下，求取n位以后的全排列。
本例中，首先固定第0位，就是分别将第0位与它本身及后面各位元素交换，得到3种不同的可能，
在固定这一位后，在考虑第1位的可能性，将第1位与它本身及其后元素交换，有两种可能性，
当前两位元素确定后，最后一位只有一种可能性。因此一共有6种可能。

将列表的第0位与第0位交换（相当于不变），此时列表变为['a', 'b', 'c']；
1.1 将列表的第1位与第1位交换（相当于不变），得到列表['a', 'b', 'c']；
1.2 将列表的第1位与第2位交换，得到列表['a', 'c', 'b']；

将列表的第0位与第1位交换，得到列表['b', 'a', 'c']；
2.1 将列表的第1位与第1位交换（相当于不变），得到列表['b', 'a', 'c']；
2.2 将列表的第1位与第2位交换，得到列表['b', 'c', 'a']；

将列表的第0位与第2位交换，得到列表['c', 'b', 'a']；
3.1 将列表的第1位与第1位交换（相当于不变），得到列表['c', 'b', 'a']；
3.2 将列表的第1位与第2位交换，得到列表['c', 'a', 'b']

这里需要注意的是，每次交换元素并回溯寻找后，都要将元素交换回来，保持没有交换前的状态。

链接：https://www.jianshu.com/p/9f8e0f00928c

"""

def exchange(arr, start, end):
    """
    使用回溯法进行全排列
    :param arr: 原始数组
    :param start: 交换的起始位置
    :param end: 交换的截止位置
    :return: []
    """
    # 结束条件，当交换到最后一位时
    if start == end:
        print arr
    # 对区间内的数据进行遍历
    for index in range(start, end):
        # 将起始点与本身及其后面的数进行交换，也就是让每种可能性都在该位置展示一次
        arr[start], arr[index] = arr[index], arr[start]
        # 将起始点后移一位，处理后面的情况。也就是保持起始点不动，对后面的数据，按照这个步骤进行递归处理
        exchange(arr, start+1, end)
        # 交换完以后，恢复没有交换前的原始状态
        arr[index], arr[start] = arr[start], arr[index]

arr = ["a", "b", "c", "d"]
print exchange(arr, 0, len(arr))